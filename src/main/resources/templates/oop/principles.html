<h2>Принципы</h2>

<p>
    <span class="tooltip">
        <span class="tooltiptext">YAGNI</span>
        <span class="tooltiphint">You aren't gonna need it</span>
    </span> — отказ от реализации функциональности без непосредственной необходимости.
</p>

<p>
    То, что не задумано в системе, не должно появляться в коде.
</p>

<p>Написание кода, который не нужен сейчас, но может понадобиться в будущем, приводит к:</p>
<ul>
    <li>
        Меньшему времени на добавление, тестирование и улучшчение необходимой функциональности.
    </li>
    <li>
        Трата времени на поддержку еще не используемых функций.
    </li>
    <li>
        Ненужная функциональность в будущем может затруднить добавление нужной.
    </li>
    <li>
        Гадание как именно будут выглядеть функциональность которая еще не нужна.
    </li>
    <li>
        Увеличение сложности.
    </li>
    <li>
        Риски для безопасности.
    </li>
    <li>
        При добавлении новой функциональности сложно остановиться.
    </li>
</ul>

<p>
    <span class="tooltip">
        <span class="tooltiptext">KISS</span>
        <span class="tooltiphint">Keep it simple, stupid</span>
    </span> — Сложность ПО не должна превышать необходимую.
</p>

<p>
    Очень общий принцип.
    Простой код - естественный, понятный.
</p>

<p>
    <span class="tooltip">
        <span class="tooltiptext">DRY</span>
        <span class="tooltiphint">Don't repeat yourself</span>
    </span> — Каждая часть знаний должна иметь единственное представление в системе.<br>
    Single responsibility?
</p>

<p>SOLID принципы</p>
<ul>
    <li>
        <span class="tooltip">
            <span class="tooltiptext">Единственой ответственности</span>
            <span class="tooltiphint">Single responsibility</span>
        </span> – класс решает только одну задачу.<br>
        Изменение только одной части требований к ПО должно привести к изменению класса.
    </li>
    <li>
        <span class="tooltip">
            <span class="tooltiptext">Открытости-закрытости</span>
            <span class="tooltiphint">Open-closed</span>
        </span> – программные сущности должны быть открыты для расширения, но закрыты для модификации.
    </li>
    <li>
        <span class="tooltip">
            <span class="tooltiptext">Подстановки Б. Лисков</span>
            <span class="tooltiphint">Liskov substitution</span>
        </span> – потомки должны быть применимы к местам использования родителей.<br>
        При наследование должно сохраняться отношение "Является".
    </li>
    <li>
        <span class="tooltip">
            <span class="tooltiptext">Разделения интерфейсов</span>
            <span class="tooltiphint">Interface segregation</span>
        </span> – Лучше ряд специфических интерфейсов, чем один общий.<br>
        Зачем клиенту реализовывать интерфейс, которым он не пользуется?<br>
    </li>
    <li>
        <span class="tooltip">
            <span class="tooltiptext">Инверсии зависимостей</span>
            <span class="tooltiphint">Dependency inversion</span>
        </span> – сущности должны зависеть от абстракций а не деталей.<br>
        Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.<br>
        Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.
    </li>
</ul>


<!--Separation of concerns-->
<!--Inversion of Control-->

<!--cohesion-->
<!--coupling-->

<!--Разделение на управляемые части-->
<!--Преждевременная оптимизация-->

<!--Сказанное в той или иной мере было и использовалось до ООП.-->
<!--Заслуга ООП в объединении принципов, вынесения некоторых из них на уровень ЯП и представлении программы в виде объектов.-->

<!--Как очертить что входит в эту задачу и часть требований? Задача специалиста, вопрос опыта, компетенций.-->
<!--По крайней мере это должно пониматься и быть сформулировано. Мой класс отвечает за ... А не за ... и за...-->
<!--Можно попытаться придумать навзвание класса исходя из его обязанностей и это не должно вызывать затруднение.-->

<!--Принципы абстрактны-->