<h2>ООП подробнее</h2>

<p>
    <span class="tooltip">
        <span class="tooltiptext">Абстрактный метод</span>
        <span class="tooltiphint">Abstract method</span>
    </span> — метод с пустым телом, определяемый в наследниках класса.<br>
</p>

<p>
    <span class="tooltip">
        <span class="tooltiptext">Абстрактный класс</span>
        <span class="tooltiphint">Abstract class</span>
    </span> — класс, экземпляр которого нельзя создать, может иметь абстрактные методы.<br>
    Описание базовой функциональности для использования или переопределения в наследниках.<br>
    Нужен если несколько классов разделяют общую функциональность.
<p>

<p>
    <span class="tooltip">
        <span class="tooltiptext">Интерфейс</span>
        <span class="tooltiphint">Interface</span>
    </span> — перечень объявлений методов.<br>
    Он описывает функциональность, которую наследник должен полностью реализовать.<br>
    Нужен если классы объединяет схожее поведение, реализация которого отличается.<br>
    Чтобы описать отдельно от реализации как клиент будет взаимодествовать с классом.
</p>

<p>
    Обычно класс наследутеся от одного абстрактного и реализует несколько интерфейсов.<br>
    Можно сказать, что интерфейс является абстрактным классом.
</p>

<details>
    <summary>Почему так? Множественное, ромбовидное наследование.</summary>
    <p>
        Множественное наследование — класс может иметь более одного суперкласса.<br>
        В таком случае возможна проблема ромбовидного наследования:<br>
        если классы по разному переопределили метод, то какую из реализаций использовать в их наследнике?<br>
        Одно из популярных решений - наследование от одного класса и реализация нескольких интерфейсов.<br>
    </p>
</details>

<p>
    <b>Для чего инкапсуляция?</b> Чтобы можно было менять реализацию, сохраная API.<br>
    Чтобы клиент полагался на API, не зависел от служебных данных и не видел их.<br>
    Чтобы сложнее было нарушить работу класса непреднамеренно.<br>
</p>

<p>
    <b>Для чего абстракция?</b> Отделить использование объектов от деталей их реализации (интерфейс).<br>
    Уменьшение сложности.<br>
</p>

<p>
    <b>Для чего наследование?</b> Воспринимать потомки как родителей (Отношение «является»).<br>
    Повторное использование кода.
</p>

<p>
    <b>Для чего полиморфизм?</b> Связан с наследованием. Гибкость, меньший объем кода.<br>
    <i>Параметрический</i> – выполнение одного кода для разных аргументов (сложение строк и чисел).<br>
    <i>Переопределения</i> (ad hoc) – исполнение разного кода для тех же данных (переопределение метода).
    <br>
</p>

<p>Приемы используемые вместе с наследованием:</p>
<ul>
    <li>
         <span class="tooltip">
             <span class="tooltiptext">Делегация</span>
             <span class="tooltiphint">Delegation</span>
         </span> — передача части работы другому классу (внутреннему);<br>
    </li>
    <li>
        <span class="tooltip">
             <span class="tooltiptext">Композиция</span>
             <span class="tooltiphint">Composition</span>
         </span> — объект включается в контейнер, управляется им и не существует вне его;<br>
    </li>
    <li>
        <span class="tooltip">
             <span class="tooltiptext">Агрегация</span>
             <span class="tooltiphint">Aggregation</span>
         </span> — объект включается в контейнер (в виде ссылки), может существовать вне контейнера.<br>
    </li>
</ul>